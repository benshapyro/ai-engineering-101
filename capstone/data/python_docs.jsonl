{"id": "python_001", "title": "List Comprehensions", "content": "List comprehensions provide a concise way to create lists in Python. The syntax is [expression for item in iterable if condition]. For example, squares = [x**2 for x in range(10)] creates a list of squares. List comprehensions are generally faster and more Pythonic than equivalent for loops.", "category": "fundamentals", "tags": ["lists", "comprehensions", "syntax"], "difficulty": "beginner"}
{"id": "python_002", "title": "Dictionary Methods", "content": "Python dictionaries have several useful methods: .get(key, default) retrieves a value with a fallback, .keys() returns all keys, .values() returns all values, .items() returns key-value pairs as tuples. The .pop(key) method removes and returns a value, while .update(other_dict) merges dictionaries.", "category": "data_structures", "tags": ["dictionaries", "methods"], "difficulty": "beginner"}
{"id": "python_003", "title": "Decorators", "content": "Decorators are functions that modify the behavior of other functions. They use the @decorator syntax above a function definition. Common use cases include logging, timing, authentication, and caching. A decorator takes a function as input and returns a modified function. Example: @login_required wraps a function to check authentication first.", "category": "advanced", "tags": ["decorators", "functions", "metaprogramming"], "difficulty": "advanced"}
{"id": "python_004", "title": "Generators", "content": "Generators are functions that yield values one at a time using the yield keyword instead of return. They are memory-efficient for large datasets because values are computed on-demand. Generator expressions use parentheses: (x**2 for x in range(1000000)). Use generators when processing large sequences or infinite streams.", "category": "advanced", "tags": ["generators", "yield", "memory"], "difficulty": "intermediate"}
{"id": "python_005", "title": "Context Managers", "content": "Context managers handle setup and cleanup automatically using the 'with' statement. The most common example is file handling: with open('file.txt') as f: data = f.read(). This ensures files are properly closed even if errors occur. You can create custom context managers using __enter__ and __exit__ methods or the @contextmanager decorator.", "category": "advanced", "tags": ["context_managers", "with", "resources"], "difficulty": "intermediate"}
{"id": "python_006", "title": "Lambda Functions", "content": "Lambda functions are anonymous, single-expression functions defined with the lambda keyword. Syntax: lambda arguments: expression. Example: square = lambda x: x**2. Lambdas are commonly used with map(), filter(), and sorted(). While concise, complex logic should use regular def functions for readability.", "category": "fundamentals", "tags": ["lambda", "functions", "functional"], "difficulty": "beginner"}
{"id": "python_007", "title": "Exception Handling", "content": "Python uses try-except blocks for error handling. The try block contains code that might raise an exception, except catches specific exceptions, else runs if no exception occurs, and finally always runs for cleanup. Best practice: catch specific exceptions like ValueError, not bare except. Use raise to throw exceptions and custom exception classes inherit from Exception.", "category": "fundamentals", "tags": ["exceptions", "error_handling", "try_except"], "difficulty": "beginner"}
{"id": "python_008", "title": "Async/Await", "content": "Asyncio enables asynchronous programming in Python. Async functions are defined with async def and called with await. Use async for I/O-bound operations like network requests or file operations. The event loop manages coroutine execution. asyncio.gather() runs multiple coroutines concurrently. Async is not suitable for CPU-bound tasks; use multiprocessing instead.", "category": "advanced", "tags": ["async", "await", "concurrency", "asyncio"], "difficulty": "advanced"}
{"id": "python_009", "title": "Type Hints", "content": "Type hints (PEP 484) add optional type annotations to Python code. Syntax: def func(name: str, age: int) -> str. Common types include int, str, float, bool, List[T], Dict[K, V], Optional[T], Union[T1, T2]. Use mypy or pyright for static type checking. Type hints improve code documentation and catch bugs early without affecting runtime performance.", "category": "best_practices", "tags": ["types", "annotations", "mypy"], "difficulty": "intermediate"}
{"id": "python_010", "title": "Virtual Environments", "content": "Virtual environments isolate Python project dependencies. Create with python -m venv venv_name, activate with source venv_name/bin/activate (Linux/Mac) or venv_name\\Scripts\\activate (Windows). Install packages with pip install package_name. Requirements files (requirements.txt) track dependencies: pip freeze > requirements.txt. Use venv for project isolation to avoid dependency conflicts.", "category": "tools", "tags": ["venv", "pip", "dependencies"], "difficulty": "beginner"}
